%!TEX program = xelatex

\documentclass[11pt, oldfontcommands, oneside, a4paper]{memoir}
\usepackage{etoolbox}

\input{layout/template}

\setmainlanguage{dutch}
\PolyglossiaSetup{dutch}{indentfirst=false}

\graphicspath{ {images/} }



\title{C++ Concepts}
\begin{document}
\titleGM
\tableofcontents

\chapter{Dynamisch Geheugen}
C++ ondersteunt drie manieren om geheugen toe te wijzen in een programma:

\begin{description}
	\item[Statisch geheugenbeheer] wordt gebruikt voor statische en globale variabelen. Het geheugen wordt meestal pas terug vrijgegeven wanneer het programma klaar is.
	\item[Automatisch geheugenbeheer] wordt gebruikt voor functie argumenten en locale variabelen. Het geheugen wordt gereserveerd op het moment dat het een code blok actief is, en verwijderd op het eind van dat blok. Met een code blok bedoelen we alle code tussen twee accolades.
	\item[Dynamisch geheugenbeheer] is waar we het nu over hebben.
\end{description}

Statisch en automatisch geheugen hebben twee dingen met mekaar gemeen:

\begin{itemize}
	\item De grootte van de variabele of array moet bekend zijn bij de compilatie.
	\item De toewijzing en het vrijgeven van het geheugen gebeurt automatisch.
\end{itemize}

Meestal is dit voldoende. Maar er zijn situaties waarin deze beperkingen een probleem zijn. Vooral wanneer we niet kunnen voorspellen hoeveel geheugen we nodig zullen hebben.

Als je bijvoorbeeld een gebruiker records in een database laten aanmaken, dan weten we nooit hoeveel records die gebruiker zal maken. Of wanneer we een bestand willen inlezen, dan weten we niet hoe groot dat bestand zal zijn.

Als we steeds vooraf moeten aangeven hoeveel geheugen we nodig hebben, dan zullen we maar best voldoende geheugen aanvragen en hopen dat het genoeg is:

\begin{code}
Record record[500]; // hopelijk maakt de gebruiker minder dan 500 records
Monster monster[40]; // hopelijk is de speler dood voor monster 41 komt
Polygon rendering[30000]; // deze game engine zal maar beter minder dan 30.000 polygons nodig hebben
\end{code}

Dit is slechte code om minstens vier redenen:

\begin{itemize}
	\item Ten eerste leidt het tot verspilling van geheugen dat we niet nodig hebben. Als we geheugen aanvragen voor 500 records terwijl de gebruiker er maar 50 nodig heeft, dan had de computer 90\% van dat geheugen beter voor iets anders gebruikt.
	\item Ten tweede weten we op deze manier niet zeker hoeveel geheugen er nu werkelijk in gebruik is. Er is dan wel plaats voor 40 monsters in deze array, maar bevat monster[25] nu werkelijk een monster of is dit een lege plaats waar misschien ooit een monster kan zitten? We hebben dus extra code nodig om te weten welke monsters werkelijk actief zijn. Dat maakt de code weer complexer.
	\item Ten derde worden normale variabelen gealloceerd op de \textbf{stack}. Dat is een deel van het programmageheugen dat beperkt is in grootte. In visual studio is de default stack 1MB groot. Als dan je meer dan een MB stack geheugen gebruikt, dan crasht je programma. Probeer het volgende maar eens uit:

\begin{code}
int main() {
	int array[1000000]; // reserveer 1 miljoen integers (ongeveer 4MB geheugen)
}
\end{code}

	Maar 1MB geheugen gebruiken zou voor de meeste programma's niet werkbaar zijn. Zeker niet als er met graphics gewerkt wordt.

	\item De vierde en belangrijkste reden is dat dit kan leiden tot overflows. Wat gebeurt er wanneer de gebruiker 600 records inleest uit de database, terwijl we maar ruimte hebben voor 500 records? We kunnen zelf een foutmelding programmeren, slechts 500 records lezen of (in het slechtste geval) het programma laten crashen.
\end{itemize}

Gelukkig bestaat er een oplossing voor deze problemen: dynamisch geheugenbeheer. Dit laat toe dat een programma tijdens de uitvoering extra geheugen vraagt aan het operating system. Dit geheugen komt niet van de stack maar uit een veel grotere pool geheugen die we de \textbf{heap} noemen. Op recente computers kan de heap verschillende gigabytes groot zijn.

\section{Variabelen dynamisch toewijzen}
Om geheugen te reserveren voor een enkele variabele (geen array) gebruiken we de \textbf{new} operator:

\begin{code}
new int;
\end{code}

In het voorbeeld hierboven reserveren we geheugen voor \'e\'en integer op de heap. De new operator heeft als resultaat een pointer naar dat geheugen. Bijgevolg zal je om iets te kunnen doen met dat geheugen, de pointer moeten onthouden:

\begin{code}
int * ptr = new int; // ptr verwijst naar een geheugenadres waar een integer in past 
*ptr = 42; // zet 42 op de plaats waar ptr naar verwijst
\end{code}

Je ziet dat je niet met dynamisch geheugen kan werken zonder pointers. Je zou immers nooit iets kunnen doen met dat geheugen.

Het is ook mogelijk om het geheugen dadelijk te initialiseren met een waarde. Dat kan zo:

\begin{code}
int * ptr = new int(42);
\end{code}

\subsection{Hoe werkt dynamisch geheugen?}
Je computer heeft geheugen dat beschikbaar is voor applicaties. Wanneer je een programma start, dan zal het operating system dat programma in een deel van het geheugen laden. Dit geheugen bestaat uit verschillende zones, elk met een eigen doel. E\'en zone bevat je code (in gecompileerde vorm). Een ander deel dient om te onthouden waar het programma mee bezig is (welke functie de huidige functie aanriep, om later op die plaats verder te kunnen gaan). Maar het meeste geheugen zit gewoon te wachten tot een programma er om vraagt.

Wanneer je dynamisch geheugen aanvraagt, dan vraag je het operating system om een deel van dat geheugen voor jouw programma te reserveren. Als het OS dat kan, zal het het adres van dat geheugen aan je programma bezorgen. Vanaf dat moment kan je programma met dat geheugen doen wat het wil. Wanneer je programma het geheugen niet langer nodig heeft, kan het dat geheugen teruggeven aan het operating system. Het OS kan dat geheugen dan later weer voor een ander programma gebruiken.

\textbf{Anders dan bij statisch geheugen is het je programma zelf dat verantwoordelijk is voor het aanvragen en verwijderen van dynamisch geheugen.}

\subsection{Geheugen terug vrijgeven}

Wanneer je klaar bent met dynamisch toegewezen geheugen, dan moet je C++ expliciet vertellen om het terug te geven aan het OS. Voor gewone variabelen gebeurt dat met de operator \textbf{delete}:

\begin{code}
delete ptr;
ptr = nullptr;
\end{code}

De delete operator verwijdert niet echt iets. Het meldt gewoon aan het OS dat je programma het geheugen niet meer nodig heeft. Ook al lijkt het dus alsof we een variabele verwijderen, dat is niet het geval! De pointer verwijst nog steeds naar hetzelfde adres en je kan er nog steeds een andere waarde aan toewijzen. Tenminste, C++ zal je niet tegenhouden. Aangezien het geheugen ondertussen in gebruik kan zijn door een ander programma, kan je niet langer zeker zijn van zijn inhoud.

Een pointer naar vrijgegeven geheugen noemen we een \textbf{hangende pointer}. Zo'n pointer nogmaals proberen verwijderen zorgt ook voor problemen. Test het volgende programma eens uit:

\begin{code}
#include <iostream>
 
int main()
{
    int *ptr = new int; // reserveer geheugen voor een integer
    *ptr = 7; // zet een waarde in dat geheugen
 
    delete ptr; // geef het geheugen terug aan het OS
 
    std::cout << *ptr; // onvoorspelbaar!
    delete ptr; // onvoorspelbaar!
 
    return 0;
}
\end{code}

Waarschijnlijk zal het programma niet crashen wanneer je de inhoud van de pointer op het scherm zet, maar de kans is groot dat die inhoud niet meer klopt. Maar de extra delete operator zal meestal wel een crash veroorzaken.

Geheugen terug vrijgeven kan zelfs meerdere hangende pointers veroorzaken. Zo in het volgende voorbeeld:

\begin{code}
#include <iostream>
 
int main()
{
    int *ptr = new int; 
    int *otherPtr = ptr; // otherPtr verwijst nu naar dezelfde plaats in het geheugen
 
    delete ptr; // geef het geheugen vrij, ptr en otherPtr zijn nu hangende pointers
    ptr = nullptr; // ptr is nu een null pointer
 
    // toch is otherPtr nog steeds een hangende pointer!!!
 
    return 0;
}
\end{code}

In regel zal je steeds, na het vrijgeven van geheugen, alle pointers naar dat geheugen gelijkstellen aan nullptr.
 
\subsection{null pointers}
Null pointers zijn bijzonder handig wanneer je met dynamisch geheugen werkt. Ten eerste kan je een pointer die nergens naar verwijst steeds naar null laten verwijzen. Dat maakt het gemakkelijk om te weten of je al dan niet om nieuw geheugen moet vragen.

\begin{code}
int * ptr = nullptr;
if (!ptr) ptr = new int;
\end{code}

Daarnaast zal delete ook enkel geheugen vrijgeven wanneer de pointer niet null is. Je zag net dat dubbele deletes een probleem kunnen zijn, maar het volgende is dus perfect mogelijk.

\begin{code}
int * ptr = new int(42);
delete ptr;
ptr = nullptr;
delete ptr;
\end{code}

Natuurlijk is deze code vrij zinloos. Maar wanneer je later pointers met classes combineert, komt deze techniek wel van pas.

\subsection{Memory leaks}

Eerder werd al gezegd dat je zelf verantwoordelijk bent voor het verwijderen van dynamisch geheugen. Dat wil zeggen dat dit geheugen, wanneer je het vergeet te verwijderen, blijft bestaan tot je programma stopt en het operating system het in jouw plaats verwijdert. Daarop mag je echter niet rekenen. Stel je voor dat je een programma hebt om afbeeldingen te bekijken. Bij het laden van elke afbeelding reserveer je geheugen voor die afbeelding, maar je vergeet het vrij te geven. Halverwege de foto-avond over je reis naar Scherpenheuvel zou je programma kunnen crashen omdat al het geheugen in gebruik is! (Al zou het in dat geval ook goddelijke interventie kunnen zijn.)

Dit noemen we een \textbf{memory leak}. Het OS krijgt het geheugen niet terug, ook al heeft je programma het niet meer nodig. Memory leaks kunnen op verschillende manieren ontstaan. Ten eerste kan je vergeten het geheugen vrij te geven:

\begin{code}
void doSomething()
{
    int *ptr = new int;
}
// ptr bestaat niet meer, maar het geheugen is niet vrijgegen
// -> memory leak
\end{code}

Maar je kan ook de pointer overschrijven met een ander adres, waarna je nooit meer aan het oorspronkelijke adres kan:

\begin{code}
int value = 5;
int * ptr = new int;
ptr = &value; // het oude adres is verloren -> memory leak
\end{code}

Of je kan twee keer geheugen aanvragen met dezelfde pointer, zonder de vorige terug vrij te geven.

\begin{code}
int * ptr = new int;
ptr = new int; // memory leak: check!
\end{code}

\begin{exercise}
	\begin{itemize}
		\item Maak een programma waarin je geheugen aanvraagt voor een integer en een float. Wijs beiden een waarde toe. Daarna toon je de som van beiden op het scherm. Geef het geheugen vrij voor je het programma afsluit.
		
		\item Verklaar wat er gebeurt in het volgende programma. Veroorzaakt dit een memory leak? Zo ja, waar? Of waarom niet?

		\begin{code}
int main()
{
  int * ptr = nullptr;
  int * ptr2 = nullptr;

  for (int i = 0; i < 10; i++) {    
    if (ptr) {
      cout << *ptr << endl;
      ptr2 = ptr;
    }
    ptr = new int(i);
    delete ptr2;
    ptr2 = nullptr;
  }

  cin.get();
  return 0;
}
		\end{code}

	\end{itemize}
\end{exercise}

\section{Dynamic arrays}

Dynamisch geheugen komt pas echt van pas wanneer je met geheugencontainers wil werken. In het begin van dit hoofstuk zagen we enkele statische arrays:

\begin{code}
Record record[500]; 
Monster monster[40];
Polygon rendering[30000]; 
\end{code}

Je leerde al dat dit geheugen in de stack wordt gezet, die wel eens te klein kan zijn voor een grote array. Een ander probleem is dat je al van voor de start van je programma moet weten hoeveel elementen je nodig hebt.

Een dynamische array is op dat vlak meer flexibel:

\begin{code} 
#include <iostream>
int main()
{
    std::cout << "Enter a positive integer: ";
    int size;
    std::cin >> size;
 
    int *array = new int[size]; // use array new.  Note that size does not need to be constant!
 
    std::cout << "I just allocated an array of size " << size << '\n';
 
    array[0] = 5; // set element 0 to value 5
 
    delete[] array; // use array delete to deallocate array
    array = nullptr; 
 
    return 0;
}
\end{code}

Het lijkt er op dat we opnieuw de operator \textsl{new} gebruiken. Maar eigenlijk zal de compiler hier \textsl{new[]} gebruiken, omdat hij ziet dat het resultaat een array moet zijn. De haakjes staan dan wel achter het type, maar dat is voor de compiler geen probleem.

Je ziet ook dat de waarde voor het aantal elementen niet vooraf bepaald moet worden. Je kan nu gewoon een integer doorgeven. Daarnaast is het ook belangrijk dat we nu heap geheugen gebruiken. Daardoor kan het programma veel meer geheugen reserveren. Zo is er geen probleem met de volgende code:

\begin{code}
int main() {
  int *list = new int[1000000];
}
\end{code}

\subsection{Dynamische arrays verwijderen}
Om een dynamische array te verwijderen, gebruik je de array versie van delete operator: \textsl{delete[]}. Beginnende programmeurs vergissen zich hier dikwijls en gebruiken de gewone delete operator (zonder haakjes). Die geeft enkel het eerste element van de array terug vrij. En zo zit je weer met een memory leak.

\subsection{Waarden toewijzen}
Eenmaal je een geldige array hebt, kan je eenvoudig waarden toevoegen:

\begin{code}
int main() {
  std::string * text = new std::string[10];
  text[0] = "hello world";
  std::cout << "our favorite: " << text[0] << std::endl; 
  delete[] text;
  text = nullptr;
}
\end{code}

\subsection{Resize}
Eenmaal je een array gemaakt hebt, kan je de grootte niet wijzigen. Om snel alle elementen in een array af te gaan is het noodzakelijk dat die elementen allemaal op een rijtje staan in het heap geheugen. Maar wanneer je extra elementen zou aanmaken, dan is het mogelijk dat het geheugen vlak na de array al aan een ander programma werd gegeven. Daarom is een resize niet zomaar mogelijk. 

Er zijn wel classes in de library die je toelaten om de grootte van een container aan te passen, zoals \eeClass{std::vector}. In praktijk zal zulk een class wat extra elementen voorzien voor het geval je die nodig zou hebben, en indien dat niet volstaat de volledige container copi\"eren naar een nieuwe plaats in het geheugen om vervolgens het oorspronkelijke geheugen terug vrij te geven.

Libraries zoals Esenthel, waar snelheid van cruciaal belang is, hebben betere manieren om dat aan te pakken. Maar die houden dan meestal meer geheugen bezet.

\begin{exercise}
Schrijf een programma dat de gebruiker vraagt hoeveel namen hij wil ingeven. Daarna vraagt het programma om iedere naam. Tot slot toont het de hele lijst van ingegeven namen op het scherm.

Hint: gebruik een dynamische array van std::string om de namen op te slaan.
\end{exercise}

\chapter{Operator Overloading}
\section{Inleiding}

In C++ zijn operators eigenlijk functies. Wanneer je de volgende bewerking ziet staan:

\begin{code}
int z = x + y;
\end{code}

dan maakt de compiler daar dit van:

\begin{code}
int z = operator+(x, y);
\end{code}

C++ heeft met andere woorden een functie met de volgende definitie, waarin \textsl{operator+} de naam van de functie is.

\begin{code}
int operator+(int value1, int value2);
\end{code}

Ook voor doubles, floats en strings beschikt C++ al over deze functies. Maar wanneer je een eigen class maakt, dan bestaat dergelijke functie niet.

\begin{code}
class Vec2 {
  int x, y;
};

int main() {
  Vec2 v1, v2;
  Vec2 v3 = v1 + v2; // error
}
\end{code}

Om bovenstaande code te laten werken, moeten we een operator+ defini\"eren voor Vec2. Die techniek noemen we `operator overloading'. Er zijn wel enkele beperkingen aan verbonden:

\begin{enumerate}
  \item Bijna elke operator kan je overladen, behalve conditional (?:), scope(::), member selector (.) en member pointer selector (.*).
  \item Je kan geen operators overladen die niet bestaan. Nieuwe operators maken is dus niet mogelijk. Je kan bijvoorbeeld geen operator met een dollarteken maken om euro's om te zetten naar dollars.
  \item Het is niet mogelijk om het aantal argumenten in een operator functie te wijzigen. 
  \item Je kan nooit de volgorde van bewerkingen of de associativiteit van een operator aanpassen.
\end{enumerate}

Daarnaast zijn er enkele richtlijnen die je best volgt. 

\begin{enumerate}
  \item De oorspronkelijke betekenis van de operator moet zo goed mogelijk bewaard blijven. 
  \item Wanneer de betekenis van een operator niet duidelijk is, dan gebruik je beter een gewone functie.
\end{enumerate} 

Toch zijn er zo nog voldoende mogelijkheden. Zo kan je de + operator implementeren om twee objecten van een class op te tellen. Of je implementeert de << operator om de inhoud van een class op het scherm te tonen. Je kan ook de == operator gebruiken om te controleren of twee objecten gelijk zijn. Al die mogelijkheden laten je toe om uiteindelijk je class op een intuitieve manier te gebruiken.

\section{Friend Functions}
De + en - operator zijn wellicht de meeste gebruikte. Maar kijk nog even naar de definitie:

\begin{code}
int operator+(int value1, int value2);
\end{code}

Je ziet dat deze operator geen lid is van een class. Meestal zal een operator wel toegang moeten hebben tot de private variabelen van een class, dus daar zit je met een probleem. Waar ook een oplossing voor bestaat: je maakt duidelijk dat de functie `bevriend' is met de class.

Zo bijvoorbeeld in deze class:

\begin{code}
class Rekening {
private:
  int _bedrag;

public:
  Rekening(int value) { _bedrag = value; }
  int bedrag() const { return _bedrag; }
  friend Rekening operator+(const Rekening &r1, const Rekening &r2);
};

// opgelet, de friend functie is geen lid van de class!
Rekening operator+()(const Rekening &r1, const Rekening &r2) {
  return Rekening(r1._bedrag + r2._bedrag);
}

int main() {
  Rekening r1(60000);
  Rekening r2(20);

  Rekening r3 = r1 + r2;
  std::cout << "Ik heb " << r2.bedrag() << " gespaard." << std::endl;
}
\end{code}

Je ziet dat de functie niet zo moeilijk is, zolang je je aan de regels houdt. Zo moeten de argumenten van een operator+ functie altijd twee const references zijn. Het resultaat moet steeds een nieuw object van dezelfde class zijn. Voor de eigenlijke berekening maken we hier een nieuw object, waarin we de bedragen (integers) optellen in de constructor.

\begin{exercise}
Voeg ook operator- toe aan het voorbeeld hierboven.
\end{exercise}

Nu kan je twee rekeningen samen tellen, maar misschien zou het in dit geval ook logisch zijn dat je een integer bij een bestaande rekening kan tellen. Dat kan, maar enkel wanneer je daar ook een operator voor schrijft. Voor primitives (integer, float, \ldots) is het niet nodig om een const reference te gebruiken.

\begin{code}
class Rekening {
  ...
  friend Rekening operator+(const Rekening &r1, int value);
};

Rekening operator+()(const Rekening &r1, int value) {
  return Rekening(r1._bedrag + value);
} 

\\ ergens in main:
Rekening r2 = r1 + 1000;

\end{code}

\begin{exercise}
  \begin{enumerate}
    \item Test de nieuwe operator. Wat gebeurt er wanneer je de integer vooraan zet? Voeg code toe om dat op te lossen. Maak ook een - operator met een integer.

    \item Maak een class \eeClass{Vec2} met een integer x en y. Voorzie ook + en - operators voor deze class.
  \end{enumerate}
\end{exercise}

Zoals gezegd kan je ook andere operators toevoegen. Zo zou je de \eeClass{Vec2} in de oefening hierboven een functie kunnen geven om de inhoud het het scherm te tonen:

\begin{code}
class Vec2 {
  int x, y;

  void print() {
    std::cout << "Vec2(" << x << ", " << y <<")";
  }
};
\end{code}

Deze functie heeft echter een nadeel. Omdat \eeFunc{print()} een gewone lidfunctie is, kan je ze niet midden in een output statement zetten. Je zal het op deze manier moeten doen:

\begin{code}
Vec2 v1;
std::cout << "my point is";
v1.print();
std::cout << " in 2D";
\end{code}

Het zou eenvoudiger zijn wanneer je gewoon het volgende kon schrijven:

\begin{code}
std::cout << "my point is" << v1 << " in 2D";
\end{code}

En via de << operator kan dat! Deze operator overladen is niet zo verschillend van de + operator, maar de functie argumenten zijn anders. Begin bij de uitdrukking \texttt{std::cout << point}. Als << de operator is, wat zijn dan de operatoren? Aan de linkerkant zie je het object \texttt{std::cout}. Dat is een object van de class \eeClass{std::ostream}. De rechter operator is van het type \eeClass{Vec2}. Daarom ziet de definitie er zo uit:

\begin{code}
friend std::ostream& operator<<(std::ostream &out, const Point & point);
\end{code}

De implementatie zelf is dan behoorlijk eenvoudig:

\begin{code}
friend std::ostream& operator<<(std::ostream &out, const Point & point) {
  out << "Vec2(" << x << ", " << y <<")";
  return out;
}
\end{code}

Misschien is de return value hier wel het meest vreemd. Bij de + operator was de linkerzijde van de operator ook een waarde. Maar nu staat aan de linkerkant een output stream. Door die hier als eerste argument te gebruiken en dat argument ook als resultaat terug te geven, kan je heel eenvoudig meerdere outputs combineren.

\begin{code}
Vec2 v1, v2;
std::cout << "Punt 1 is: " << v1 << "en punt 2 is: " << v2 << std::endl;
\end{code} 

\section{Lidfuncties}
Wanneer het eerste argument van een operator functie een const reference naar dezelfde class is, dan kan de operator functie ook als lidfunctie geschreven worden. Je laat het eerste argument in dat geval gewoon weg:

\begin{code}
class Vec2 {
public:
  int x, y;
  Vec2 operator+(const Vec2 & value) {
    Vec2 result;
    result.x = x + value.x; 
    result.y = y + value.y;
    return result;
  }
};
\end{code}

\begin{exercise}
Schrijf zelf een extra + operator voor een integer. (Je telt die integer dan op bij zowel x als y.) Kan je in de bewerking de integer ook vooraan zetten? Leg uit.

Voorzie ook een += operator en controleer of die werkt.
\end{exercise}



\chapter{Template Functies}

\section{inleiding}

Je weet ondertussen dat functies en classes het eenvoudiger maken om grote programma's te schrijven. Toch zijn ze soms wat beperkt, vooral omdat c++ je verplicht om elke variabele een type te geven. Stel dat je de volgende functie wil schrijven:

\begin{code}
int max(int nX, int nY) {
	if (nX > nY) return nX;
	return nY;
}
\end{code}

Je kan deze code eenvoudig in een programma gebruiken om te weten welke variabele de grootste waarde bevat:

\begin{code}
#include <iostream>
using namespace std;

int main() {
	cout << max(1, 3) << endl;
	cin.get();	
	return 0;
}
\end{code}

Maar deze code zal niet het gewenste resultaat geven wanneer je floats gebruikt:

\begin{code}
cout << max(0.3, 0.24) << endl;
\end{code}

Dat komt omdat de functie max \eeClass{integers} verwacht. De \eeClass{floats} hierboven worden daarom afgerond naar beneden om aan de eisen van de functie \eeFunc{max} te voldoen. Daarom hebben we een tweede functie \eeFunc{max} nodig, die \eeClass{floats} als argumenten heeft:

\begin{code}
float max(float fX, float fY) {
	if (fX > fY) return fX;
	return fY;
}
\end{code}

Je zal zien dat je functie \eeFunc{max} nu zowel met gehele getallen als met floats kan gebruiken. De compiler zal de meest geschikte functie kiezen. Maar voor jou als programmeur is dat wel meer werk. Nu zijn dit nog maar twee functies, maar wie weet voor welke data je nog allemaal een maximum nodig hebt! Denk aan \eeClass{char}, \eeClass{double}, of misschien zelfs een eigen class \eeClass{Circle}.

Hier komen functie templates van pas. Een template versie van de functie max kan er zo uit zien:

\begin{code}
Type max(Type tX, Type tY) {
  if (tX > tY) return tX;
  return tY;
}
\end{code}

De functie verwijst nu niet langer naar \eeClass{float} of \eeClass{integer}, maar naar een \eeClass{Type}. \textsl{(Die naam is overigens vrij te kiezen, maar Type of T worden het meest gebruikt.)} Wanneer je een programma met deze functie compileert, dan krijg je echter een foutmelding: de compiler gaat er van uit dat \eeClass{Type} een class is, en kent die class niet. Je hebt met andere woorden nergens gedeclareerd wat een \eeClass{Type} is.

Om aan te geven dat het om een template gaat, voeg je een extra regel toe, net voor de declaratie van de functie:

\begin{code}
template <typename Type>
Type max(Type tX, Type tY) {
  if (tX > tY) return tX;
  return tY;
}
\end{code}

Op deze manier geeft je aan dat dit een template functie is, en dat \eeClass{Type} de naam van het gebruikte type is. Je kan deze functie nu gebruiken met eender welk type, zolang dat type maar een operator > heeft. Die is immers nodig om te bepalen welke variabele de grootste waarde heeft.

\begin{code}
cout << max(   3,     7) << endl;
cout << max(-0.2, -0.46) << endl;
cout << max('a' ,   'b') << endl;
\end{code}

\begin{exercise}
\begin{enumerate}
	\item Maak een template functie \eeFunc{max3} die de grootste waarde van drie argumenten als resultaat heeft.
	\item Maak een template functie \eeFunc{avg} die het gemiddelde van 3 waarden als resultaat geeft.
\end{enumerate}
\end{exercise}

\section{De compiler}

Voor we verder gaan met templates, is het belangrijk te weten wat de compiler doet met template functies. Het zijn immers \textbf{templates} en geen echte functies. Een programma kan niet werken met deze templates, dus moet de compiler wat extra werk doen om hier een echt programma van te maken. Op het moment dat je de volgende code in je programma gebruikt:

\begin{code}
cout << max(3, 7) << endl;
\end{code}

\ldots\ zal de compiler denken: ``oh, ik heb een functie \eeFunc{max} nodig met integers.'' De compiler voegt dan de volgende functie toe aan je programma:

\begin{code}
int max(int tX, int tY) {
  if (tX > tY) return tX;
  return tY;
}
\end{code}

Met andere woorden: de compiler maakt een kopie van de template en vervangt \eeClass{Type} overal door \eeClass{int}. Gebruik je verder in je programma ook dit statement:

\begin{code}
cout << max(3.4, 5.6) << endl;
\end{code}

\ldots\ dan zal de compiler nog een extra kopie van je functie maken, maar dit maal \eeClass{Type} vervangen door \eeClass{double}. Dat wil zeggen dat de twee functies die je oorspronkelijk schreef nu door de compiler gemaakt worden. Het resultaat is dus hetzelfde, maar je hebt wel minder werk. Ook belangrijk is dat de compiler deze functies enkel maakt wanneer ze nodig zijn. Als je nergens een je programma een functie \eeFunc{max} gebruikt met twee char variabelen, dan zal de compiler die functie ook niet genereren.

Soms moet je de compiler wel wat helpen. Wanneer je de functie op deze manier gebruikt:

\begin{code}
cout << max(3.4, 5) << endl;
\end{code}

\ldots\ komt de compiler er niet uit. Moet hij nu de functie met het type \eeClass{double} of het type \eeClass{int} maken? Het eerste argument is immers een double, maar het tweede is een integer. Je moet dan zelf aangeven welke functie er nodig is:

\begin{code}
cout << max<double>(3.4, 5) << endl;
\end{code}

Deze notatie komt je hopelijk bekend voor. Bij meer complexe templates is het steeds nodig om aan te geven welk type er nodig is. Je hebt deze notatie dus al gebruikt in onder meer:

\begin{code}
std::vector<int> intList;
Memx<Circle> circles;
\end{code}

\chapter{Template Classes}
We starten met een eenvoudige class voor een 2D positie. Die zou er zo uit kunnen zien:

\begin{code}
class Vec {
public:
  int x() { return _x; }
  int y() { return _y; }

  void set(int x, int y) {
  	_x = x;
  	_y = y;
  }

  void set(const Vec & other) {
  	_x = other._x;
  	_y = other._y;
  }

  void print() {
  	cout << "x: " << _x << " y: " << _y << endl;
  }

private:
  int _x, _y;
};
\end{code}

Gevolgd door een kort programma:

\begin{code}
int main() {
  Vec pos1;
  pos1.set(1, 2);
  pos1.print();

  Vec pos2;
  pos2.set(pos1);
  pos2.print();

  cin.get();
  return 0;
}
\end{code}

Wil je deze class aanpassen zodat je ook floats en doubles kan gebruiken? Je kan dezelfde techniek als voordien toepassen. Voorzie een template declaratie en vervang \eeClass{int} overal door \eeClass{Type}. Voer daarna het programma uit.

Je zal zien dat de compiler hier behoorlijk van streek raakt. Het probleem zit al in de eerste regel van het programma:

\begin{code}
Vec pos1;
\end{code}

Bij een template functie kan de compiler uit de argumenten meestal afleiden met welk type hij een kopie van de template moet maken. Maar hier wordt dat pas duidelijk wanneer de functie \eeFunc{set(int, int)} gebruikt wordt. En dat is te laat. Daarom zal je bij een class template steeds moeten aangeven welk type je wil gebruiken:

\begin{code}
Vec<int> pos1;
\end{code}

\begin{note}
Een van de redenen waarom Esenthel geen template class voor \eeClass{Vec} gebruikt, is dat die class zoveel gebruikt wordt dat het onhandig is om telkens het type mee te geven. Templates worden in C++ eerder voor containers gebruikt, en dat is ook zo in Esenthel.
\end{note}

\begin{exercise}
\begin{enumerate}
	\item Maak een template class Vec3 met een Z co\"ordinaat. Pas de main functie aan om deze class te testen.
	\item Maak een template class Color met r, g en b waarden. Voorzie een functie om de kleuren in te stellen en een functie om ze op het scherm te printen.
\end{enumerate}
\end{exercise}

\end{document}

