\chapter{De Client}

Wat de client betreft beperkt deze cursus zich tot de elementen die betrekking hebben op het netwerk-gedeelte. Andere classes zoals \texttt{detailsGui} zijn tijdens de cursus al meermaals aan bod gekomen. Je word verwacht deze classes zelf uit te werken.

\section{De `Peer' Class}
Met `Peers' bedoelen we andere clients die zich in je buurt bevinden. Gemakkelijkheidshalve gaan we er van uit dat alle actieve clients hier in mekaars buurt zijn. Bij grotere games zal naar de positie van een client gekeken worden. De server beslist dan welke speler dicht genoeg in mekaars buurt zijn om als peer beschouwd te worden.

De class \texttt{peer} heeft als base class \texttt{netClient}. Iedere \texttt{peer} heeft dus een positie, een kleur en een naam. Die worden enkel via het netwerk aangepast. 

Wat een \texttt{peer} class bijzonder maakt is het gebruik van interpolatie. Positie updates worden ongeveer 10 keer per seconde verstuurd. Maar om een vloeiende beweging op het scherm te tonen is een fijnere aanpassing van de posities nodig. Meer posities over het netwerk versturen is een optie, maar die belast het netwerk al snel te veel. Daarom gaan we de positiewijzigingen tussen de updates zelf invullen. Daar hebben we interpolators voor nodig. In dit geval is dat een \eeClass{Interpolator2} voor de interpolatie van de positie, een \eeClass{Vec2}. Bij een 3D project zou je een \eeClass{Interpolator3} gebruiken. Daarnaast heb je ook steeds een interpolator voor de tijd nodig: \eeClass{InterpolatorTime}. De lege class ziet er zo uit:

\begin{code}
class peer : netClient
{
   Interpolator2 iPos;
   InterpolatorTime iTime;
   
   // hier worden functies toegevoegd
}
\end{code} 

\subsection{Update}
De update functie zal eerst de \eeClass{InterpolatorTime} updaten. Daarna moet ook de positie geupdate worden, met de interpolatietijd als argument.

\begin{code}
void update()
{
	iTime.update();
	iPos.update(iTime);
}
\end{code}

\subsection{posities}
We voorzien nog twee extra functies om het werken met posities vlot te laten verlopen. De eerste is \eeFunc{recalculatePos}. Deze functie zullen we telkens uitvoeren wanneer we een nieuwe positie via het netwerk ontvangen. Ze zorgt ervoor dat de interpolators hun werk kunnen doen.

\begin{code}
void recalculatePos()
{
	iPos.step(pos, iTime);
	iTime.step();
}
\end{code}

De positie die we gebruiken om de peer op het scherm te tonen krijgen we via \eeFunc{iPos()}. Dit zou verwarrend kunnen zijn, want via \eeClass{netClient} bestaat er ook al een variabele `pos'. Om te voorkomen dat we ons vergissen, maken we een extra functie \eeFunc{getPos()}.

\begin{code}
Vec2 getPos()
{
	return iPos();
}
\end{code}

\subsection{Draw}
Tot slot heeft de peer class een \eeClass{Draw()} functie nodig. Hierin tekenen we een cirkel en een tekst op het scherm. We gebruiken de functie \eeFunc{getPos()} om de ge\"interpoleerde positie op te vragen.

\begin{code}
void draw()
{
	Circle(0.05, getPos()).draw(color);
	Vec2 textPos = getPos();
	textPos.y += 0.1;
	D.text(textPos, name);
}
\end{code}

\begin{exercise}
Werk de volledige \eeClass{peer} class uit aan de hand van de bovenstaande code.
\end{exercise}

\section{PeerManager}

Aangezien er meer dan \'e\'en peer actief kan zijn, maken we hiervoor een typische manager class. Die bevat een geheugencontainer om peers te onthouden, evenals functies om een peer toe te voegen, te verwijderen of te zoeken. Ook is er een functie voorzien om alle peers in een keer op het scherm te tekenen.

De lege class ziet er zo uit:

\begin{code}
class peerManager {
private:
  Memx<peer> peers;
	
public:
  // add other code
}

peerManager PeerManager;
\end{code}

\subsection{Peer toevoegen}
Je hebt een functie nodig om een nieuwe peer toe te voegen. Deze functie is ongeveer gelijk aan functies die je in het verleden al gebruikte om iets aan een manager class toe te voegen. Een klein verschil is dat je de nieuwe ID van de andere speler als functieargument gebruikt. We stellen in deze functie dadelijk het ID in van de nieuwe speler, maar geven ook een referentie naar dat nieuwe object terug als functieresultaat. Zo kan de code die deze functie gebruikt de peer verder aanpassen.

\begin{code}
peer & add(int ID)
{
	peer & p = peers.New();
	p.id = ID;
	return p;
}
\end{code}

\subsection{Peer vinden}
Er is ook een functie nodig om te zoeken naar een peer met een bepaalde ID. Deze keer geven we geen referentie maar een pointer als resultaat. Het is immers mogelijk dat de peer met een bepaald ID niet bestaat. Maar het is onmogelijk om een lege referentie als resultaat te geven. Een lege pointer kan wel, dat is de `null' pointer.

\begin{code}
peer * find(int ID) 
{
	FREPA(peers)
	{
		 if(peers[i].id == ID)
		 {
				return &peers[i];
		 }
	}
	
	return null;
} 
\end{code}

\subsection{Peer verwijderen}
Wanneer een speler offline gaat, dan moet die ook bij de andere clients verdwijnen. Daarom voorzien we een functie \eeFunc{remove}. In deze functie zullen we de speler met een gegeven ID uit de container verwijderen.

\begin{code}
void remove(int ID)
{
	FREPA(peers)
	{
		 if(peers[i].id == ID)
		 {
				peers.removeValid(i);
				return;
		 }
	}
}
\end{code}

\subsection{Peers tellen}
We willen ook weten hoeveel spelers er online zijn. Dat getal is gelijk aan het aantal elementen in de container met peers. Maar omdat die container private is, voorzien we ook een functie om deze informatie aan andere classes door te geven.

\begin{code}
int elms() 
{
	return peers.elms();
}
\end{code}

\subsection{Update en Draw}
Tot slot zijn er de update en draw functies. Die zullen de gelijknamige functies van elke peer uitvoeren:

\begin{code}
void update() { FREPA(peers) peers[i].update(); }
void draw  () { FREPA(peers) peers[i].draw  (); }
\end{code}

\begin{exercise}
Gebruik de bovenstaande code om de class peerManager uit te werken.
\end{exercise}

\section{Peer Messages}

Het bestand `peerMessages' bevat functies om data van het netwerk te verwerken die bedoeld is om peers aan te passen. Eventueel hadden deze functies ook in de class \texttt{peerManager} kunnen staan. Maar het is wel overzichtelijk om ze netjes samen in \'e\'en bestand te plaatsen.

\subsection{AddPeer}
\begin{code}
void AddPeer(File & f)
{
   int id = f.getInt();
   peer & p = PeerManager.add(id);
   p.readDetailsFromFile(f);
}
\end{code}

De functie \texttt{AddPeer()} haalt, zoals al deze functies, eerst het id uit het bestand. Vervolgens wordt een nieuwe peer gegenereerd die dan verder de details uit het bestand leest.

\subsection{GetPeerDetails}
\begin{code}
void GetPeerDetails(File & f)
{
   int id = f.getInt();
   // try to find a peer with this id
   peer * p = PeerManager.find(id);
   if(p != null)
   {
      p.readDetailsFromFile(f);
   }
}
\end{code}

In het geval van \texttt{GetPeerDetails()} is het mogelijk dat de functie \texttt{find()} null als resultaat heeft. Je moet dan ook controleren of dat zo is, voor je probeert de functie \texttt{readDetailsFromFile()} uit te voeren.

\subsection{GetPeerPos}
\begin{code}
void GetPeerPos(File & f)
{
   int id = f.getInt();
   peer * p = PeerManager.find(id);
   if(p != null)
   {
      p.readPosFromFile(f);
      p.recalculatePos();
   }
}
\end{code}

Deze functie lijkt sterk op de vorige. In feite zullen alle functies die gebruikt om informatie van het netwerk naar objecten over te brengen, in grote mate op mekaar lijken. In dit geval zullen we na het lezen van de positie ook de functie \eeFunc{recalculatePos()} uitvoeren. Die functie dient om de interpolators te updaten. (Zie uitleg in de vorige sectie.)

\subsection{RemovePeer}
Wanneer er een bericht binnenkomt om een peer te verwijderen, dan bevat dat bericht enkel de ID van die peer. In de class \eeClass{peerManager} hebben we een functie gemaakt die een peer verwijdert aan de hand van zijn ID. We kunnen die functie hier eenvoudig gebruiken.

\begin{code}
void RemovePeer(File & f)
{
   int id = f.getInt();
   PeerManager.remove(id);
}
\end{code}

\begin{exercise}
Voeg de 4 functies hierboven toe aan het bestand `peerMessages'.
\end{exercise}

\section{De Network Class}
Een tweede class controleert alle netwerk messages. De lege class ziet er zo uit:

\begin{code}
class network
{
private:
   Connection connection;
	 float startTime;
	 bool connected = false;
	
public:
   // ... more code ...
}
network Network;
\end{code}

Het belangrijkst hier is de class \texttt{Connection} die de engine voorziet. Die gebruik je om een verbinding te maken met een server. Je start deze verbinding in de functie \texttt{create()}.

\subsection{Create}
\begin{code}
void create()
{
	startTime = Time.curTime();
	SockAddr serverAddress;
	serverAddress.setIP("127.0.0.1", 65535);
	connection.clientConnectToServer(serverAddress);
}
\end{code}

De \texttt{startTime} stel je gelijk aan de huidige tijd. Dat is belangrijk om later te controleren hoe lang je al op een verbinding wacht. Vervolgens heb je een IP adres nodig. Dit voorbeeld gebruikt het locale adres van je computer, maar dat zal je uiteindelijk aanpassen naar een publiek IP adres. \textsl{(Bij een afgewerkt programma is het zelfs gebruikelijk om eerst ergens op een webserver een bestandje te downloaden dat het huidige IP adres bevat van de game server.)}

\subsection{Update}
De \texttt{update()} functie bestaat uit twee delen. Het eerste deel wordt uitgevoerd wanneer de verbinding nog niet in orde is. Het tweede deel kijkt, in het geval van een geldige verbinding, of er nieuwe messages zijn.

\begin{code}
void update()
{
   if(!connected)
	 {
	    // code
	 } else {
	    // more code
	 }
}
\end{code}

In het deel waarin er nog geen verbinding is, wordt eerst gekeken of er nieuwe messages zijn. Het eerste bericht dat je de server laat terugsturen is \texttt{M\_HELLO}. Als er een nieuw bericht is, dan controleer je of dat het juiste bericht is en wordt \texttt{connected} gelijk aan \texttt{true}.

Indien er geen verbinding is en er is ook geen nieuw bericht, dan is het tijd om enkele testen uit te voeren. Je controleert of de state van de connectie wel in orde is. In het geval die gelijk is aan \texttt{CONNECT\_INVALID} of \texttt{CONNECT\_VERSION\_CONFLICT} dan is het duidelijk dat de verbinding niet zal lukken. We kunnen dat laten weten aan de gebruiker. Ook als we langer dan 5 seconden wachten op een server kunnen we aannemen dat het niet meer in orde komt. 

\begin{code}
if(connection.receive(0))
{
	if(connection.data.getByte() == M_HELLO) connected = true;
} else
{
	// not connected yet, check for errors
	if(connection.state() == CONNECT_INVALID || connection.state() == CONNECT_VERSION_CONFLICT)
	{
		 Exit("Couldn't connect to server");
	}
	
	if(Time.curTime() - startTime > 5)
	{
		 Exit("Connection Timeout");
	}
	
	Time.wait(1); // wait a bit
}
\end{code}

Als er w\'el een verbinding is, dan controleren we ook op nieuwe messages. De eerste byte laat je weten om welk bericht het gaat. Daarmee beslis je welke functie je uitvoert en geef je de rest van het bestand \textsl{(connection.data)} door aan die functie:

\begin{code}
REP(8) if(connection.receive(0))
{
	byte message = connection.data.getByte();
	switch(message)
	{
		 case M_ADD_CLIENT   : AddPeer       (connection.data); break;            
		 case M_CLIENT_FULL  : GetPeerDetails(connection.data); break;               
		 case M_CLIENT_POS   : GetPeerPos    (connection.data); break;              
		 case M_REMOVE_CLIENT: RemovePeer    (connection.data); break;
	}
}
\end{code}



Tot slot is er ook nog de functie \texttt{send()}. Die kan je overal in je programma gebruiken om data naar de server te sturen. Veiligheidshalve wordt de leespositie van de file eerst terug op nul gezet.

\begin{code}
void send(File & f)
{
   f.pos(0); 
   connection.send(f);
}

bool isConnected() {
  return connected;
}
\end{code}

\begin{exercise}
Maak aan de hand van de bovenstaande code de class \eeClass{network} in het gelijknamige bestand.
\end{exercise}

\section{De Player Class}
Het programma bevat ook een class voor een player. Net zoals de \texttt{client} class bij de server, wordt ook hier \texttt{netClient} als basis gebruikt. Die bevat immers variabelen voor de naam, de kleur en de positie van de player.

Hier start je met de volgende class:

\begin{code}
class player : netClient {
private:
	float timeForUpdate = 0;
	
public:
  // add functions later
}
player Player;
\end{code}

\subsection{Create}
De create functie is in dit geval kort. We stellen enkel een standaard kleur in voor de speler.

\begin{code}
void create() {
  color = RED;
}
\end{code}

\subsection{Update}

In de \texttt{update()} functie staat eerst de gebruikelijke code om de speler te bewegen:

\begin{code}
if(Kb.b(KB_LEFT )) pos.x -= Time.ad();
if(Kb.b(KB_RIGHT)) pos.x += Time.ad();
if(Kb.b(KB_UP   )) pos.y += Time.ad();
if(Kb.b(KB_DOWN )) pos.y -= Time.ad();
Clamp(pos.x, D.viewRect().min.x, D.viewRect().max.x);
Clamp(pos.y, D.viewRect().min.y, D.viewRect().max.y);
\end{code}

Daarna volgt de code om de positie regelmatig naar de server te sturen. We doen dit elke 0.1 seconde. In dat geval wordt er een bericht van het type \texttt{M\_CLIENT\_POS} gegenereerd dat via de Network class naar de server verzonden wordt.

\begin{code}
if(timeForUpdate > 0)
{
	 timeForUpdate -= Time.ad();
} else {
	 // notify server of new position
	 File f;
	 f.writeMem().putByte(M_CLIENT_POS);
	 writePosToFile(f);
	 Network.send(f);
	 
	 timeForUpdate = 0.1;
}
\end{code}

\subsection{Draw}
De draw functie is eenvoudig. Net zoals in de \eeClass{peer} class tekenen we een cirkel en een tekst op het scherm:

\begin{code}
void draw()
{
	Circle(0.05, pos).draw(color);
	Vec2 textPos = pos;
	textPos.y += 0.1;
	D.text(textPos, name);
}
\end{code}

\subsection{setDetails}

Ook van belang is de functie \texttt{setDetails()}, die wordt uitgevoerd wanneer er op de `ok'-knop wordt gedrukt in de gui. Op het moment dat we de naam en de kleur van de speler wijzigen, maken we een bericht van het type \texttt{M\_CLIENT\_FULL} dat we naar de server sturen.

\begin{code}
void setDetails(C Str & name, C Color & color)
{
	T.name = name;
	T.color = color;
	
	// send details to server
	File f;
	f.writeMem().putByte(M_CLIENT_FULL);
	writeDetailsToFile(f);
	Network.send(f);
}
\end{code}

\begin{note}
In tegenstelling tot de server code voor het versturen van de berichten, voegen we nu niet het id van deze client toe. De server weet immers al van welke client dit komt.
\end{note}

\begin{exercise}
Voeg de bovenstaande code samen tot de class \eeClass{player}.
\end{exercise}

\section{Main Program Loop}

Een volwaardig programma zal waarschijnlijk uit meerdere application states bestaan. Om dit voorbeeld eenvoudig te houden is enkel de default state aanwezig. We overlopen even de verschillende functies.

\subsection{InitPre}

\begin{code}
void InitPre()
{
   EE_INIT();
   App.flag=APP_WORK_IN_BACKGROUND|APP_NO_PAUSE_ON_WINDOW_MOVE_SIZE;
}
\end{code}

De \eeFunc{InitPre} functie bevat een extra lijn code om enkele application flags in te stellen. Deze flags zijn opties die beinvloeden hoe het programma zich gedraagt. Om de werking van deze app te demonstreren zullen we verschillende instances van deze app gelijktijdig openen. We willen dat die allemaal het scherm updaten, niet enkel de applicatie met de window focus.

\subsection{Init}
\begin{code}
bool Init()
{
   Network   .create();
   Player    .create();
   DetailsGui.create();
   
   return true;
}
\end{code}

Er is niets bijzonders aan deze code. De verschillende objecten (netwerk, player en gui) worden ge\"initialiseerd.

\subsection{Shut}
\begin{code}
void Shut() {}
\end{code}

\subsection{Update}
\begin{code}
bool Update()
{
   if(Kb.bp(KB_ESC))return false;
   
   Network.update();
   
   // the program is not really active as long as the 
   // client is not connected to the server
   if(Network.isConnected())
   {
      if(Kb.bp(KB_F1)) DetailsGui.show();
      Gui.update();
      
      Player.update();
      PeerManager.update();
   }
   return true;
}
\end{code}

Hierin is enkel het volgende concept nieuw:

\begin{code}
if(Network.isConnected())
{
	// ...
}
\end{code}

Het \texttt{Network} object dat we hieronder uitwerken bevat een functie om te controleren of er een verbinding is. In dit voorbeeld gebruiken wordt het eigenlijke programma niet geupdated of getoond zolang dat niet het geval is. In een echt programma zal je waarschijnlijk wel een loginscherm willen tonen op dat moment.

\subsection{Draw}
\begin{code}
void Draw()
{
   D.clear(WHITE);
   
   // Don't do anything if not connected
   if(!Network.isConnected())
   {
      D.text(0, 0, "Waiting for Server...");
      return;
   }
   
   // draw peers and player on screen
   PeerManager.draw();
   Player.draw();
   
   // add texts and gui
   D.text(0, -0.9,  S + "Press F1 for options");
   D.text(0, -0.8,  S + "Connected players: " + PeerManager.elms());
   Gui.draw();
}
\end{code}

\begin{exercise}
Voeg alle code hierboven toe aan het bestand `main'.
\end{exercise}

\section{De Gui}
De gui voor dit project kan je zeker zelf uitwerken. Maak een gui Window met een \eeClass{TextLine} om je naam in te vullen, een \eeClass{Button} `color' die een \eeClass{ColorPicker} toont en een \eeClass{Button} `Ok' om de nieuwe waarden toe te kennen aan de Player.

Je zou met behulp van de code in de hoofdstukken over GUI zelf je gui class moeten kunnen schrijven. In de callback functie voor de button `Ok' voer je de functie \eeFunc{Player.setDetails()} uit. Als argument zet je daar natuurlijk de nieuwe naam en kleur.

\begin{exercise}
Werk de gui class uit.
\end{exercise}