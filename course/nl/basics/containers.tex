\chapter{Containers}

Tot hier toe moest je altijd aan het begin van je programma alle objecten defini\"eren die je wil gebruiken. Voor een kleine oefening is dat geen probleem, maar in een groot project wordt dat al snel heel onoverzichtelijk. Ook is het onmogelijk om op deze manier extra objecten bij te maken terwijl je programma loopt.

Wanneer je verschillende objecten van hetzelfde type nodig hebt, dan kan je daar een container voor voorzien. Je declareert dan enkel de container, en voegt er later objecten aan toe. Een container die eenvoudig is in gebruik is \eeClass{Memc}. De container vereist dat je bij de declaratie aangeeft wat voor objecten je er in wil zetten. Zo kan je in een \eeClass{Memc<float>} floats opslaan. Wil je rechthoeken in een container? Dan gebruik je \eeClass{Memc<Rect>}. Zo kan je eender welk soort objecten in een container steken. Hieronder zie je een container voor cirkels.

\begin{code}
// Declareer een container voor cirkels
Memc<Circle> circles;

void InitPre()
{
   EE_INIT();
}

bool Init()
{
  // genereer 10 cirkels  
	for(int i = 0; i < 10; i++)
   {
			// De functie New maakt een nieuwe cirkel. We gebruiken dadelijk de
			// functie set van de class Circle om de straal en de positie in 
			// te stellen.
      circles.New().set(0.1, RandomF(-D.w(), D.w()), RandomF(-D.h(), D.h()));
   }
   return true;
}

void Shut() {}

bool Update()
{
   if(Kb.bp(KB_ESC)) return false;  
   return true;
}

void Draw()
{
   D.clear(BLACK);
   
	 // Ga alle cirkels in de container af en 
	 // teken ze op het scherm.
   for(int i = 0; i < circles.elms(); i++)
   {
      circles[i].draw(RED);
   }
}
\end{code}

\begin{exercise}
\begin{enumerate}
\item Wat gebeurt er als je de code om de cirkels te genereren per vergissing in Update in plaats van in Init zet?
\item Zet de functie terug in Init, maar voorzie in Update code om telkens wanneer je op de spatiebalk drukt \'e\'en extra cirkel te maken.
\item Toon op het scherm een afbeelding in plaats van een cirkel. \textsl{(Te moeilijk? Begin dan met een rechthoek.)}
\end{enumerate}
\end{exercise}

\section{New()}
De functie \eeFunc{New()} voegt een nieuw element toe aan het eind van de container. Omdat deze functie ook een referentie naar dat nieuwe object als resultaat geeft, kan je daar ook dadelijk een functie van dat object aan toevoegen. Dat is de reden waarom we de \eeFunc{set} functie van Circle kunnen gebruiken in het bovenstaande voorbeeld.

Maar wat als je nu twee functies van het nieuwe object wil gebruiken? Je zou het volgende kunnen proberen:

\begin{code}
for(int i = 0; i < 10; i++)
{
	circles.New().set(0.1, RandomF(-D.w(), D.w()), RandomF(-D.h(), D.h()));
	circels.New().extend(-0.05);
}
\end{code}

\ldots maar dat werkt natuurlijk niet. Je maakt nu bij elke iteratie van de for loop 2 cirkels. Bij de eerste voer je de functie \eeFunc{set} uit, bij de tweede de functie \eeFunc{extend}. De oplossing bestaat er in de referentie naar het nieuwe object even bij te houden. Je leert later meer over referenties, maar voorlopig is het voldoende als je weet dat je een ampersand (\&) tussen de class en de naam plaatst:

\begin{code}
for(int i = 0; i < 10; i++)
{
	Circle & c = circles.New();
	c.set(0.1, RandomF(-D.w(), D.w()), RandomF(-D.h(), D.h()));
	c.extend(-0.05);
}
\end{code}

Je maakt met andere woorden een tijdelijke verwijzing naar je nieuwe object. Hierboven gebruik ik de naam `c'. Daarna kan ja via die referentie de functies uitvoeren die je wil.

\section{Objecten gebruiken}
Meestal zal je in de Update of Draw alle elementen van een container willen overlopen. Bijvoorbeeld om ze op het scherm te tonen. Daarvoor bestaat er de functie \eeFunc{elms()} die je vertelt hoeveel elementen er op dit moment in de container zitten. Met een eenvoudige for-loop kan je die dan allemaal af gaan. Zoals je ziet, geven we tussen vierkante haakjes aan welk element we willen gebruiken, net zoals je dat bij een primitieve array zou doen.

\begin{code}
for(int i = 0; i < circles.elms(); i++)
{
  circles[i].draw(RED);
}
\end{code}

Omdat je zo dikwijls alle elementen van een container moet overlopen, bestaat er ook een `shortcut'. De macro \eeFunc{REPA}. Je zou de vorige code dus ook zo kunnen schrijven:

\begin{code}
REPA(circles)
{
  circles[i].draw(RED);
}
\end{code}

Onthoud dit als `repeat all'. Je kiest natuurlijk zelf of je de for-loop dan wel deze shortcut gebruikt.

Je kan meer doen dan objecten op het scherm tonen. Bedenk zelf eens wat de volgende code, geplaatst in Update, doet.

\begin{code}
REPA(circles)
{
	circles[i].pos.y += Time.d();
	if(circles[i].pos.y > D.h()) {
	  circles[i].pos.y -= (2*D.h() + RandomF(1));
	}
}
\end{code}

\begin{exercise}
\begin{itemize}
\item Test de bovenstaande code in een progamma.
\item Voeg een functie toe om een cirkel toe te voegen wanneer je op de spatiebalk drukt.
\item In plaats van een vaste straal gebruik je een random waarde tussen 0.01 en 0.1.
\item Teken enkel de omtrek van de cirkels, in het wit. Maak de achtergrond blauw.
\item Roep luid door de klas waar dit je aan doet denken.
\end{itemize}
\end{exercise}

\section{Objecten genereren}
Objecten genereren tijdens of aan het begin van een programma is iets wat je best goed beheerst. Daarom zie je nu enkele mogelijkheden om je op weg te helpen. Denk er wel aan dat dit slechts voorbeelden zijn. De mogelijkheden waarop je containers gebruikt zijn zowat onuitputtelijk.

\subsection{Tijdens Init}

Tien cirkels op willekeurige posities:

\begin{code}
for(int i = 0; i < 10; i++)
{
	Circle & c = circles.New();
	c.set(0.1, RandomF(-D.w(), D.w()), RandomF(-D.h(), D.h()));
}
\end{code}

Cirkels van de linkerkant tot de rechterkant van het scherm:

\begin{code}
for(float i = -D.w(); i < D.w(); i += 0.2) {
  circles.New().set(0.1, i, 0);
}
\end{code}

Vierkanten over het hele scherm:
\begin{code}
for(float i = -D.w(); i < D.w(); i += 0.2)
{
	for(float j = -D.h();  j < D.h();  j += 0.2)
	{
		 rects.New().set(i - 0.05, j - 0.05, i + 0.05, j + 0.05);
	}     
}
\end{code}

\begin{exercise}
Probeer de bovenstaande mogelijkheden uit, en toon ook steeds de gegenereerde objecten op het scherm.
\end{exercise}

\subsection{Tijdens Update}

Via interactie:
\begin{code}
if(Kb.bp(KB_SPACE)) {
  circles.New().set(  RandomF(0.05, 0.2)
	                  , RandomF(-D.w(), D.w())
	                  , RandomF(-D.h(), D.h())
  );
}
\end{code}

Interactie met de positie van de muis:

\begin{code}
if(Ms.bp(0)) {
  circles.New().set(0.05, Ms.pos());
}
\end{code}

Met een timer:
\begin{code}
Flt timer = 3; // deze regel zet je boven aan je programma, 
               
// de rest hoort in update
if(timer > 0) timer -= Time.d();
else {
  timer = 3;
	circles.New().set(  RandomF(0.05, 0.2)
	                  , RandomF(-D.w(), D.w())
										, RandomF(-D.h(), D.h())
  );
}
\end{code}

\begin{exercise}
Probeer de bovenstaande mogelijkheden uit, en toon ook steeds de gegenereerde objecten op het scherm.
\end{exercise}

\section{Objecten verwijderen}
Je kan uiteraard ook objecten verwijderen uit een container. Dit is op zich niet moeilijk:

\begin{code}
Memc<Vec2> points;

// ... voeg ergens punten toe

points.remove(0); // verwijder het eerste punt
\end{code}

Je kan dus met de functie \eeFunc{remove} en als argument de index van het object dat je wil verwijderen, een object in de container wissen. Dikwijls zal je dat echter in een loop willen doen. In dat geval moet je opletten dat je het object niet meer gebruikt nadat je het verwijdert. Dat gebeurt sneller dan je denkt:

\begin{code}
for(int i = 0; i < points.elms(); i++) {
  if(points[i].y < -D.h()) points.remove(i);
	points[i].y -= Time.d();
}
\end{code}

In de bovenstaande code worden alle punten naar beneden verplaatst. Wanneer een punt onder aan het scherm komt, dan wordt het uit de container gehaald. Het probleem stelt zich wanneer je het laatste punt verwijdert. Je probeert daarna het laatste punt te verplaatsen, maar omdat de container nu een element minder bevat is de index van het laatste punt ongeldig geworden. Je kan dat natuurlijk oplossen door \eeFunc{remove} altijd op het eind te plaatsen:

\begin{code}
for(int i = 0; i < points.elms(); i++) {
	points[i].y -= Time.d();
  if(points[i].y < -D.h()) points.remove(i);
}
\end{code}

Moeilijker wordt het wanneer je twee containers combineert. In het volgende voorbeeld kijken we of een punt een cirkel raakt. Hiervoor moeten we alle punten en alle cirkels met mekaar vergelijken.

\begin{code}
for(int i = 0; i < points.elms(); i++) {
	for(int j = 0; j < circles.elms(); j++) {
	  if(Cuts(points[i], circles[j])) {
		  points.remove(i);
		  circles.remove(j);
		  // op dit moment is er een punt minder, maar zullen de volgende cirkels nog 
		  // steeds met dit punt vergeleken worden. Om dat te voorkomen stoppen we hier 
			// de binnenste loop met een break:
			break;
		}		
	}
}
\end{code}

Tot slot kan je een container ook nog in \'e\'en keer helemaal leegmaken:

\begin{code}
points.clear();
\end{code}

\section{Een spelletje}

\begin{enumerate}
\item Maak een driehoek onder aan je scherm die je met de pijltjestoetsen heen en weer kan bewegen.
\item Voorzie een container voor de class \eeClass{Vec2}. Telkens als je op de spatiebalk drukt voeg je een element toe op de positie van de driehoek.
\item In de update functie verhoog je de y waarde van elk element in de container. (Gebruik \eeClass{Time.d()}!) Wanneer een element de bovenkant van het scherm bereikt, verwijder je het uit de container.
\item In de \eeFunc{Draw()} functie teken je alle elementen op het scherm.
\item Maak een tweede container voor cirkels. Elke seconde voeg je een cirkel toe aan de bovenkant van het scherm.
\item In de update functie ga je alle cirkels naar beneden bewegen.
\item Toon de cirkels in de \eeFunc{Draw()} functie.
\item Wanneer een cirkel en een punt mekaar raken, dan verwijder je ze beiden.
\item Wanneer een cirkel de driehoek raakt, dan toon je 'Game Over' op het scherm.
\end{enumerate}

Je kan dit concept nog verder afwerken. Zo kan je voorkomen dat er nog nieuwe cirkels bijkomen na een game over, of dat je nog kan bewegen en schieten. Cirkels zouden ook steeds sneller kunnen verschijnen of sneller bewegen naarmate je langer speelt. Je kan ook een score op het scherm tonen of een aantal levens voorzien.
