\chapter{Pointers}

\section{Introduction}
By know you've learned that references are pretty neat. But before references existed, there were pointers. Just like references, they are used to store a memory address. But while references are hard to use wrong, pointers allow you to abuse them in every possible way. They're the bondage lovers of programming!

For instance: a reference \textsl{has} to have a valid address when you create it. And once created, the address can never change. You can't create an empty reference and pass the address later on. Pointers on the other hand, can point to anything or nothing. And you can change the contained address as many times as you like.

In most circumstances, using a reference is a lot safer. When a function asks for reference arguments, you can just provide regular objects. It's hard to do something wrong there. But you might run into problems when you want to return a reference. Take this code for example:

\begin{code}
class players {
  Memc<Player> list;
	
  Player &  add(Vec2 & pos, Str & name) {
    Player & p = list.add();
    p.set(pos, name);
    return p;
  }	  

  Player & findByName(Str & name) {
    FREPA(list) {
      if(Equal(list[i].getName(), name) {
        return list[i];
      }
    }
  }	
}
// global object
players Players;

// somewhere in your application
Players.add(Vec2(1,1), "niceGuy");
player & friend = Players.findByName("coolGuy");
\end{code}

The \eeFunc{add()} method won't give you problems. The reference arguments will always exist when you pass the to this method. (Either they are real objects, or they are existing references. And references cannot be empty.) The result will be valid too, because we are certain a new object will be made and returned.

Now take a look at the method \eeFunc{findByName()}. This method also returns a reference to a player. As long as the player you're looking for actually exists, there isn't any problem. But what if it doesn't? From what object would you return a reference? Remember, a reference can never be referencing a non existing object. So here are your options:

\begin{itemize}
  \item create a a new player: This enables you to return a valid reference to the player with this name. But when you use a method created by someone else, this is not really the behaviour you should expect. A method to find something should not create the object it is looking for. Otherwise, how are you able to find out if something exists or not?
  \item return a reference to the first player in the list: This might sound like a good idea. At least you do return a valid reference. But what if you're actually looking for that first player? The method returns the first object in the list, but now you don't know if this is because the object does not exist, or because it is actually the first object.
\end{itemize}

None of the options you have is a good idea. What we need is a way to have our method tell us ``'Hey, I don't have the object you're looking for. Stop buggering me!''. Or something slightly more polite.

\section{Pointers to the Rescue}

A pointer \textsl{can} point to an object. But it doesn't have to. They're like references without the safeguards. Here's a little idea to familiarize you with the idea:

Suppose you have a room full of lockers. Every locker can hold exactly one item. Now you put a mobile phone in locker 1. After a while, you decide to move the phone to locker 2. But just in case someone is looking for this phone in the first locker, you leave a note in there: `hey, the mobile phone is stored in locker 2 now'.

Locker 1 now points to locker 2. In fact, we can move the phone around and put it in any locker we like. As long as we update the note in locker 1, everyone is able to get our phone with just one easy step: use the location stored in locker 1.

You might be asking yourself: why on earth don't we just put the phone itself in locker 1 all the time? And you're right. Let us make it more complicated: imagine \textsl{every} locker has a phone, except for locker 1. For reasons beyond comprehension, the company owning these lockers wants to make sure all phones are used equally. So when someone uses the first phone, the next person should use the second phone. When the last phone is used, we'll have to use the first one again.

This could get really complicated. Imagine you have to notify everyone in the building that you've made phonecall and used the phone in locker 3. And everyone would have to remember that. Won't it be a lot easier to use a simple procedure?

\begin{itemize}
  \item Look in locker 1 for a pointer to another locker.
  \item Use the locker found in locker 1.
  \item Increase the locker number (pointer) in locker 1.
\end{itemize}

When all phones are completely discharged, we could even replace the note with the locker ID with an empty note. Everyone would instantly know there's no phone available when the note is empty.

\section{Pointers 101}
\subsection{Declaring a Pointer}
This is how a pointer is declared:

\begin{code}
int * p1;
int* p2;
int *p3;
Str * textPtr;
Player * playerPtr;
\end{code}

As you see, the use of spaces does not matter very much. It is best to choose one notation and stick to it. 

\subsection{Assign an Address.}
When you declare a reference, you \textsl{have} to assign a value to it. With pointers, you don't really have to do that. But you already know that an declaring an integer without assigning it a value results in a random number. The same happens with pointers. A new pointer points to a random address in memory. This is not wrong, but it will most likely crash your application when you try to use it.

\begin{code}
int * i; // could point to anything!
\end{code}

In most cases you will want to assign an actual address. This can be done by assigning the address of an existing variable. Mind though, you'll need to assign the \textsl{address} of the variabel, not the value it contains.

In other words, this is wrong:
\begin{code}
int i = 42;
int * p = i; // tries to assign the value of i as an address in p
\end{code}

The pass the address of a variable, use and ampersand (\&). Like this:

\begin{code}
int   i = 42;
int * p = &i; // declaration and initialisation
int * p;      // declaration only
p       = &i; // assign an address
p       =  i; // auch! wrong!!! 
\end{code}    


\subsection{Changing a value through its pointer}
Rather often you will use a pointer to alter the value it is pointing to. But assigning a value to the pointer itself is wrong. So how do you that? You use an asterisk.

\begin{code}
int   i = 42;
int * p = i ; // assign the address of i to p
*p      = 43; // assign a value to i through the pointer
\end{code}

It is also possible to assign the value of another pointer, like this:

\begin{code}
*p1 = *p2;
\end{code}

\subsection{Pointer to null}
An unassigned pointer points to random memory. So how do you make an `empty' pointer, pointing to nothing? You assign a `null' address. We also call this a `null pointer'.

\begin{code}
int * p1 = null;
\end{code}

You could now rewrite the code at the beginning of this chapter. Remember, the whole problem was that we could not return a name when none was found.

\begin{code}
class players {
  Memc<Player> list;
  
  // no problem with references here
  Circle &  add(Vec2 & pos, Str & name) {
    Player & p = list.add();
    p.set(pos, name);
    return p;
  }	  

  // a pointer is used instead of a reference
  Circle * findByName(Str & name) {
    FREPA(list) {
      if(Equal(list[i].getName(), name) {
        return &list[i]; // notice the ampersand!
      }
    }
    // no player found with this name
    return null;
  }	
}
// globaal object
players Players;

// somewhere in your application
Players.add(Vec2(1,1), "niceGuy");
player * friend = Players.findByName("coolGuy");

// check if the player exists
if(friend != null) {
  Greet(friend);
}
\end{code} 

When no player is found with a certain name, a null pointer will be returned. By checking if the returned value is different from null, we make sure the \eeFunc{Greet(player * p)} function is only executed with a valid player. 

\begin{note}
Some memory containers (like Memb) will move their objects around when the container grows. When there isn't enough memory in the current container, the whole container will be moved to a new memory location. This means that pointers to members of that container become invalid. If you need pointers to stay valid, use a container like Memx. Otherwise, only create pointers local to a method.
\end{note} 

\section{All together}
When working with pointers and references, we can use both the symbols \& and *. What they mean depends on the situation. Below are all the posibilities.

Suppose these variable exist:

\begin{code}
int   j   = 43;
int & ref = j ;
int * ptr = &j;
\end{code}

We can use these symbols

\begin{myTable}{references and pointers}{l||l|l}
  & reference & pointer \\ 
\hline Declaration     &      & \lstinline|int * i;| \\ 
\hline Declaration and Initialisation & \lstinline|int & i = j;|  & \lstinline|int * i = &j;|\\ 
\hline Initialisation &  & \lstinline| i = &j;| \\
\hline\hline Assign value & \lstinline|i = 42;| & \lstinline|*i = 42;| \\
\hline Assign value from variable & \lstinline|i = j;| & \lstinline|*i = j;| \\
\hline Assign value from reference & \lstinline|i = ref;| & \lstinline|*i = ref;| \\
\hline Assign value from pointer & \lstinline|i = *ptr;| & \lstinline|*i = *ptr;| \\
\hline\hline Assign address &  & \lstinline| i = &j;| \\
\hline Assign addres from reference  &  & \lstinline| i = &ref;| \\
\hline Assign address from pointer &  & \lstinline| i = ptr;| \\ 
 
\end{myTable} 

References are a bit easier to use. But also less flexible. Sometimes you really need a pointer.

\begin{exercise}
\begin{enumerate}
  \item Create an application with 5 circles, spread out on the bottom of your screen. Create a memory container to hold these circles.
	\item When the mouse is on top of a circle, it should slowly move upwards.
	\item Create a function with a pointer to the highest circle as a result. Call this function in every update and keep the result in a pointer variable.
	\item Draw all circles on the screen. Before drawing a circle, compare its address with the address of the highest circle. When they are the same, draw the circle green, otherwise draw it red.
\end{enumerate}
\end{exercise}

	