\chapter{More fun with Classes}

By now, you probably have a pretty good idea how to create a class. But there's no single right way to create and use classes. Different programmers use different approaches. Mostly, they're all valid and the choices are based on personal preferences. Still, when you start working with classes, the possibilities can be a bit daunting.

In this chapter, we'll examine one approach which is very useful when working with Esenthel.  

\section{Related ideas}

Every 'idea' in your application should be a class. This idea can be the score logic, the database connection, the player, a certain type of monster and so on. A class is something you create objects from, so things like a player, a monster or a window do seems like logical candidates. And they are. But just as well can a class be a more abstract idea, like a scoring system, everything related to the network or a database connection. Or a class could just be responsible for retrieving and updating the data from one table in a database. 

Everything that is related to that idea, should be part of the class. Take a score class, for example. The following concepts clearly belong together: 

\begin{itemize}
\item a variable to store the current score
\item a variable to store the high score
\item a method to change the score
\item a method to reset the score
\item a method to compare the score with the high score
\item a method to retrieve the current score
\item \ldots
\end{itemize}

When creating a class, it is a good idea to think about the class itself for a moment. What methods could you might need later on? Maybe you won't need a reset method, but there's a good chance you will. Instead of thinking about your application, you should think about the class itself.

Beginning programmers often make the mistake to focus on their application a bit too much. The result of that is a programming session like this:

\begin{itemize}
  \item Hey, i need a way to store an view the current score. Let's make a class for that.
  \item (you write a class with a score and set and get methods)
  \item Great, now i can create a window which shows the score on the screen. Let's make a class for this window.
  \item (you write a class for the score GUI)
  \item Oh, let's add a highscore!
  \item (you alter the score class to store the high score)
  \item (you start creating a database class to store highscores)
  \item (you alter the score gui to display a high score)
  \item Actually, I need a method to add points to my score.
  \item ....
\end{itemize}

The problem with this is that within a few minutes, you're working on three or more classes at the same time. Programming is hard enough as it it! When you're trying to keep track of the content and changes of different classes at the same time, you're making everything much harder for yourself.

This is why you should try to focus on the current task: creating the class. Maybe you will implement a few methods you won't even need later on. That's OK! It is much harder when you constantly have to revisit your class because you need something which doesn't exist.

That is rule 1: think about the class, not about the application. Rule number two is: logic and interface don't mix. It's just a bad idea. We try to make a clear distinction between GUI classes, logic classes, network classes, database classes and so on.

Think about the score class one more time. You could decide that the score will be visible on the screen and implement a score method called 'draw' to do just that. But later on you need to display the score when the game is over, in a slightly different way. Will you create yet another draw method? Or when you have to line up the drawing of score with the drawing of the current level. Will you add the level to the scoring system? Level management could very well deserve its own class.

A far better approach is to create a method to retrieve the score itself. And write classes for a GUI during the game and a GUI during a game over. Those classes will retrieve the current score and decide on how to display it.

\begin{code}
class score {
  int points = 0;
  
  void reset() { points = 0;    }
  void get  () { return points; }
  void inc  () { points++;      }
}
score Score; // object

// this class will be used during the game
class overlay {
  void draw() {
    D.text(Vec2(0, 0.9), S + "Score: " + Score.getPoints());
  }
}

// this class draws a gui during game over
class gameOver {
  void draw() {
    D.text(Vec2(0,0), S + "Score: " + Score.getPoints());
  } 
}
\end{code}

\section{Setters and Getters}
It is generally considered a good idea to use methods to access a class variable. Set methods are used to store a value in a variable, get methods are used to retrieve them. These methods are very easy to create, but will protect against mistakes when your classes become more complex.

For consistency, I recommend you use the following rules to write these methods:

\begin{itemize}
\item The name of the method is equal to the name of the variable, preceded by set or get. (And with camelCaps of course)
\item The method alters the value with the same name as the method.
\item The set method has an argument of the same type as the value. It returns a reference to the class.
\item The get method returns a variable with the same type as the class variable.
\end{itemize}

Here's an example of a score class with set and get methods for an integer variable called 'points'.

\begin{code}
class score {
  int points;
  
  int  getPoints(         ) { return points ; }
  void setPoints(int value) { points = value; }
}
\end{code}

Another way to implement setters and getters would be to use a special symbol in the variable name. Most programmers use an underscore. This approach has the added bonus that there is a clear distinction between class variables and local variables, because all class variables start with an underscore.

\begin{code}
class score {
  int _points;
  
  int  points(         ) { return _points ; }
  void points(int value) { _points = value; }
}
\end{code}

\section{public and private}
In the previous example, it is still possible to change the points variable directly, without using the provided methods. This is frowned upon by most programmers. If set and get methods are provided, they should be the only way to access the class variable. Suppose your class keeps a counter to know how many times the variable has changed. It would be easy to increase this counter every time the setPoints method is called. But the result cannot be trusted as long as you can also change the value without using this method.

Everyone makes mistakes, so it is better to make sure they cannot happen. Which can be done by making the class variables private: only the member functions of the class will be able to access private variables or methods. The methods themselves can be declared public, which allows you to use them from outside the class.

\begin{code}
class score {
private:
  int points  = 0;
  int counter = 0;
  
public:  
  int getPoints() {
    return points;
  }
  
  score & setPoints(int points) {
    this->points = points;
    counter++;
    return T;
  } 
}
score Score;

// somewhere in your application
Score.points = 3; // won't work
Score.setPoints(3); // does work and increases the counter
\end{code}

\section{Global Objects}
Some classes are intended to create lots of objects. Take \eeClass{Vec2} for example: you will probably need a lot of those in your application. But other classes, like the score class above, are only meant for a single object. In this case it makes sense to construct that object globally, right below the class. A global object has the advantage that it can be used from anywhere in your application.

\section{Manager Classes}
\label{section:managerClass}

When you create a class for moving circles, because you will need a lot of moving circles in your application, it might be a good idea to create a special class to handle them. Such a 'manager' class will be responsible for creating new moving circles, updating and drawing them, and even delete them when no longer needed.

Suppose you have the following class:

\begin{code}
class myCircle {
private:
  Circle c;
  
public:
  void update() {
    // update code here
  }
  
  void draw() {
    // draw code here
  }  
}

class myCircleManager {
private:
  Memx<myCircle> list;

public:
  void createCircle() {
    myCircle & temp = list.New();
    // do something else with the new circle if you like
  }
  
  void update() {
    // update all circles
    for(int i = 0; i < list.elms(); i++) {
      list[i].update();
    }
  }
  
  void draw() {
    // draw all circles
    for(int i = 0; i < list.elms(); i++) {
        list[i].draw();
      }
    }
  }
}

myCircleManager MyCircleManager;

// your application
bool Init() {
  MyCircleManager.createCircle();
  return true;
}

bool Update() {
  MyCircleManager.update();
  return true;
}

void Draw() {
  MyCircleManager.draw();
}
\end{code}

\begin{exercise}
\begin{enumerate}
\item Create the class `movingCircle'. It should contain a \eeClass{Circle}, a \eeClass{Vec2} `direction' and a float `speed'. 
\item Add a `create' method to provide the circle with a radius and a position. This method should also assign a random float between -1 and 1 to the direction variable, and a random float between 0.5 and 2 to speed. 
\item Add an `update' method to this class. This method will add the direction, multiplied by \eeFunc{Time.d()} and `speed', to the circle's position. The update method should also check the new position. Whenever the x or y value is out of bounds (which means it is no longer visible on the screen) you should reverse the sign of that value.
\item Create a `draw' method to display the circle on the screen.
\item Create a global object of the class `movingCircle' in your application. Don't forget to add the object's methods and run your application to see the result.

\item Add a new class `circleManager' which contains a memory container for the class `movingCircle'.
\item Provide an `add' method to add a new circle to this container.
\item Provide an `update' method which calls the update method of every circle in the container.
\item Add a `draw' method to draw all circles on the screen.
\item Since you only need one object of this class, you should add it in the same file, right below the class declaration with the name `CM'.

\item Remove the object of the class `movingCircle' from your application. \textsl{(The lines where you used this object should also be erased.)}
\item In the update function of your app, execute the `add' method of CM whenever the space bar is pressed.
\item Also in this update function, execute the update method of CM. And of course the draw method should be called inside your application's Draw function.

\item Extra: write a `remove' method for the circleManager. This method should accept a position as an argument. The method should compare this position with the circles in it's container. If the provided position overlaps with a circle, this circle should be erased from the container.
\end{enumerate}
\end{exercise}

\section{Working with existing code.}
When you need to change code which already exists, there's good news and there's bad news. The good news is that it can save you some work because you don't have to start from scratch. The bad news: as long as you don't understand what's already there, you are bound to make mistakes. It can be hard to start working with code you didn't write yourself, but here's a few suggestions to get you started.

\begin{itemize}
\item Be sure to know where to find what. Examine all classes and find out what they're supposed to do.
\item Check which classes have global objects.
\item Find out which class are management classes and what see which classes they manage.
\item Are there any other classes which clearly belong together?
\item It doesn't hurt to take notes about this. A few notes about the existing classes and how they relate to each other go a long way to gain the needed insight for understanding existing code.
\end{itemize}

When you're working with classes and you feel you're stuck, ask yourself these question to get on your way:
\begin{itemize}
\item What variables does the class have? What variables do I need to change in the method I am working on. And what information can be used to calculate the result? If this information is already available in the class, just use it. Otherwise you will need to provide one or more arguments to your method.
\item What other methods does the class provide? Can the result of such a method be useful to the method you're working on?
\item When your class needs to alter an object of another class, what methods does that class provide to do what you need? If you can't find any, you may want to add that method first.
\item Will this be a set or get method? In that case you can follow the steps mentioned above to create it.
\end{itemize}







