\chapter{Methods}

Methods, or class functions, can be added to a class. Mostly, methods should be the way to interact with your class. Instead of changing member variables directly, a class should provide methods to access and alter them. Appart from providing accessors to variables, methods should also be used for any kind of action your class might perform. 

\section{Methods without arguments or result}

A plain method does exactly the same thing, every time you call it. When you think back the the class \eeClass{movingCircle}, you might want to add a method to put the circle back in the middle of the screen:

\begin{code}
class movingCircle {
  Circle c;
  Vec2 speed;
  
  void reset() {
    c.pos = Vec2(0);
  }
}

// somewhere in your application
movingCircle mc;
mc.reset();

\end{code}

In this example, the circle's position will be set to zero when the \eeFunc{reset()} method is called. This method consists of three parts:

\begin{description}
\item[void] Indicates the method has no result. (More about results in a moment.)
\item[reset] The name of the method. You can pick your own name, but of course the restrictions for variable names also apply here. (Some characters are not allowed, don't start with a number, \ldots)
\item[()] End with a couple of braces. Later on, arguments will be put between them.
\end{description}

\begin{exercise}
Add the \eeFunc{reset()} method above to the previous exercise. In the \eeFunc{Update()} function of your program, replace the code to reset the circle's position with your method.

Add a method \eeFunc{draw()} to the same class. This method will draw the circle with a certain color. Again, replace the code in your app with this method.
\end{exercise}

\section{Methods with Arguments}
A method can have one or more arguments. Arguments are used to pass values to a method. In the previous example, the \eeFunc{reset()} method didn't need an argument. We know what has to be done to put a circle back in the middle of the screen. But should you write a method to place a circle on any position, you'ld have to pass the desired position as an argument. Like so:

\begin{code}
class movingCircle {
  Circle c;
  Vec2 speed;
  
  void setPos(Vec2 pos) {
    c.pos = pos;
  }
}

// somewhere in your application
movingCircle mc;
Vec2 p(0.1, 0.4);
mc.setPos(p);
\end{code}

This method has an argument of the type \eeClass{Vec2}. The argument is used internally to alter the circle's position. It is important to remember you only pass the value of the argument, not its name or the variable itself. There is no established relationship between an method and the variables passed into it. 

\begin{code}
movingCircle mc;
Vec2 p(0.1, 0.4);
mc.setPos(p);     // pass contents of p to mc
p.x += 0.1;       // altering p does not alter the position in mc!!!
mc.setPos(p);     // call setPos again to pass the new contents to mc
\end{code}

\begin{exercise}
A the method \eeFunc{setPos} to your exercise. With it, try something new in the application: every time you press F1, a new random position should be assigned to every circle.

Add a method \eeFunc{setRadius} with a float argument. This method should change the radius of the circle. Change the radius along with the the position when you press F1. (Remember to use only small values, like a 0.01 to 0.2 range.)
\end{exercise}

\section{More arguments}
Methods are not limited to a single argument. You can add more as long as they're separated with comma's.

\begin{code}
class movingCircle {
  Circle c    ;
  Vec2   speed;
  
  void init(float r, Vec2 pos, Vec2 speed) {
    c.r     = r    ;
    c.pos   = pos  ;
    T.speed = speed;
  }
}

// somewhere in your application
movingCircle mc;
Vec2 p(0.1, 0.4);
mc.init(0.1, p, Vec2(0.3, -0.5));
\end{code}

Again, the example introduces a few new concepts:
\begin{description}
\item[T] What if the name of an argument is the same as the name of a class variable? In the example above there is an argument called 'speed', but also a variable called speed. How will the compiler know which is which, when you just type speed. Well, as a rule the most local declaration is used, which in this case is the argument. To indicate you want to use the class variable, you can use \eeClass{T}. Again in the example, the value of the argument 'speed' is passed to the class variable 'speed'. 
\item[Passing arguments] When the init method is used, a predefined \eeClass{Vec2} is used to pass the position. But speed also needs a \eeClass{Vec2}. In this case, a new Vec2 is created directly inside the braces and passed as an argument. Both options are valid, but the first one is generally used when you still need the object p after passing it to the function. This would not be possible with the second \eeClass{ Vec2} because it does not have a name.
\end{description}

\begin{exercise}
And in init method to your class and use it.
\end{exercise}

\section{Methods with a Result}
In the beginning of this chapter, I mentioned you should never use class variables directly, outside a class. You've just learned how to alter a variable through a method with an argument, but what if you wanted to retrieve the value of the variable? The answer is simple. Use the method result:


\begin{code}
class movingCircle {
  Circle c;
  Vec2 speed;
  
  void init(float r, Vec2 pos, Vec2 speed) {
    c.r         = r    ;
    c.pos       = pos  ;
    this->speed = speed;
  }
  
  float getRadius() {
    return c.r;
  }
}

// somewhere in your application
movingCircle mc;
mc.init(0.1, p, Vec2(0.3, -0.5));
float radius = mc.getRadius();

\end{code}

At the end of this example, the float radius will have a value of 0.1. This is how you create a method with a result:

\begin{itemize}
\item Use the result type instead of the keyword void. In this case we want to retrieve a radius from the circle. A radius is a float, which means the result type will also be a float.
\item The method contents should end with the keyword \texttt{return}, followed by the value that should be returned. This value will be passed to the caller.
\end{itemize}

\begin{exercise}
Add this method to your class. Add code to your application to show the radius of a circle on the screen.
\end{exercise}

\section{Methods with Arguments and Result}
One last possibility is the combination of arguments with a result. One common pitfall: although a method can have many arguments, it can only have one result.

The next example implements a \eeFunc{move} method. This method will move a circle by passing a value as an argument. This value will be added to the currrent position, but only as long as the result would not be outside of the screen. By returning a bool as a result, we can let the application know if movement succeeded.

\begin{code}
class movingCircle {
  Circle c    ;
  Vec2   speed;
  
  void init(float r, Vec2 pos, Vec2 speed) {
    c.r         = r    ;
    c.pos       = pos  ;
    this->speed = speed;
  }
  
  float getRadius() {
    return c.r;
  }
  
  bool move(Vec2 pos) {
    if(Cuts(c.pos + pos, D.viewRect())) {
      c.pos += pos;
      return true;
    } else {
      return false;
    }
  }
}

// somewhere in your application
movingCircle mc;
Vec2 p(0, 0);
mc.init(0.1, p, Vec2(0.3, -0.5));
if( !mc.move(mc.speed * Time.d()) ) {
  // do something when failed
}
\end{code}

\begin{exercise}
Add the move method to your class. The application must use this method to move the circle. This method indicates wether or not the movement was a success, so you can remove the application code to keep the circle within the screen boundaries. If the method returns false, simple call the \eeClass{reset} method to put the circle back in the middle.

It is still possible to simplify move even further. We already know movement will always be the same. So we don't actually need an argument at all! The movement can be done with the information available in the class itself. (speed and the time delta)
\end{exercise}

\section{The solution}
The complete class and app for this chapter is listed below for reference. Please compare this with your own result.

De class movingCircle:
\begin{code}
class movingCircle
{
   Circle c    ;
   Vec2   speed;
   Color  color;
   
   void create(float radius, Vec2 pos, Vec2 speed, Color color)
   {
      c.r     = radius;
      c.pos   = pos   ;
      T.speed = speed ;
      T.color = color ;
   }
   
   bool move()
   {
      Vec2 newPos = c.pos + speed * Time.d();
      if(Cuts(newPos, D.viewRect()))
      {
         c.pos = newPos;
         return true;
      } else return false;
   }
   
   Vec2 getPos()
   {
      return c.pos;
   }
   
   void setPos(Vec2 pos)
   {
      c.pos = pos;
   }
   
   void reset()
   {
      c.pos = 0;
   }
   
   void draw()
   {
      c.draw(color);
   }
}
\end{code}

The application:

\begin{code}
Memc<movingCircle> circles;

void InitPre()
{
   EE_INIT();
}

bool Init()
{ 
   return true;
}

void Shut() {}

bool Update()
{
   if(Kb.bp(KB_ESC)) return false;
  
   if(Kb.bp(KB_SPACE))
   {
      circles.New().create(RandomF(0.05, 0.1), 
                           Vec2(0), 
                           Vec2(RandomF(-1, 1), RandomF(-1, 1)), 
                           Color(Random(255), Random(255), Random(255))
                           );
   }
   
   if(Kb.bp(KB_F1))
   {
      REPA(circles)
      {
         circles[i].setPos(Vec2(RandomF(-D.w(), D.w()), RandomF(-D.h(), D.h())));
      }
   }
   
   REPA(circles)
   {
      if(!circles[i].move()) circles[i].reset();
   }
   
   return true;
}

void Draw()
{
   D.clear(BLACK);
  
   REPA(circles)
   {
      circles[i].draw();
   }
}
\end{code}