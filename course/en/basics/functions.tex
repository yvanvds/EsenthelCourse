\chapter{Methods}

Methods are little blocks of code you can add to a class. \textit{(In principle you can also add blocks of code outside a class. Those blocks are called functions.)} Methods should have a clear relation to your class though. They should alter class variables or return them in some way. Other methods could display something related to the class on the screen.

\section{Simple Methods}

The most simple method always does the same. Remember the class \eeClass{movingCircle}? Perhaps a useful method for this class could reset the position. Such a method would look like this:

\begin{code}
class movingCircle {
  Circle c;
  Vec2 speed;
  
  void reset() {
    c.pos = Vec2(0);
  }
}

// somewhere in your application
movingCircle mc;
mc.reset();
\end{code}

The method in the example above will put the circle back in the middle of the screen. Every method declaration consists out of three parts:

\begin{description}
\item[void]This indicates the method has no return value. \textit{(More about that soon.)}
\item[reset] The name of the method. You are free to choose any name you like, as long as it does not already exist.
\item[()]There could be arguments between these braces. This simple method does not have any arguments.
\end{description}

\begin{exercise}
Add the \eeFunc{reset()} method to the class, like in the example above. In the Update function of your application, you should replace the code to put the circle back in the middle with your new method. 

Add a \eeFunc{draw()} method to the class. This method will automatically draw the circle in the correct color. Again, replace your application code with this method.
\end{exercise}

\section{Methods with one Argument}
A method can have an argument. This is quite useful because it allows you to pass an option to the method. The previous methods did not need options. We know that reset will put the circle back in the middle of the screen. Should you want to put in on another spot with a method, that method must know where you want your circle to go. That could be done like this:

\begin{code}
class movingCircle {
  Circle c;
  Vec2 speed;
  
  void setPos(Vec2 pos) {
    c.pos = pos;
  }
}

// somewhere in your Init function
movingCircle mc;
Vec2 p(0.1, 0.4);
mc.setPos(p);
\end{code}

A \eeClass{Vec2} is passed as an argument to the method. This argument (a position) will be the new position for the circle. Note that in your application this position is called p, but in the method it is called pos. You only pass the value of p to the method, not its name.

\begin{exercise}
Again with the class \eeClass{movingCircle}, add a method \eeFunc{setPos} like above. To test this method, add some code to your update function. When the F1 button is pressed, all circles should get a new random position.
\end{exercise}

\section{Functions with more arguments}
Methods are not limited to one argument. You could use more, separated by comma's:

\begin{code}
class movingCircle {
  Circle c    ;
  Vec2   speed;
  
  void init(float r, Vec2 pos, Vec2 speed) {
    c.r     = r    ;
    c.pos   = pos  ;
    T.speed = speed;
  }
}

// somewhere in your Init function
movingCircle mc;
Vec2 p(0.1, 0.4);
mc.init(0.1, p, Vec2(0.3, -0.5));
\end{code}

A few things to remember:
\begin{description}
\item[T] To access a class variable, we can use \eeClass{T}. This is needed if argument has the same name as a class variable. Without \eeClass{T}, we would always use the most local variable, which is the argument. In other words:

\begin{code}
T.speed = speed;
\end{code}

\ldots means we pass the value of the argument called speed to the class variable called speed. We could use different names to avoid this confusion, but `speed' is the clearly the best name to indicate the purpose of this argument.

\item[passing arguments] The example uses a predefined \eeClass{Vec2} to pass a position. But for speed, a new \eeClass{Vec2} is created as an argument. Both options are valid. You will soon learn from experience when to use what.
\end{description}

\begin{exercise}
Add the init function above to your \eeClass{movingCircle} class. Rework your application code to use this method instead of assigning variables directly.
\end{exercise}

\section{Methods with a Result}
At the beginning of this chapter you were told not to use class variables directly outside of the class. Just now, you learned how to change their values by using methods. But how can you retrieve the value of a class variable without accessing it directly? The answer is simple: you create a method with a result:

\begin{code}
class movingCircle {
  Circle c;
  Vec2 speed;
  
  void init(float r, Vec2 pos, Vec2 speed) {
    c.r         = r    ;
    c.pos       = pos  ;
    this->speed = speed;
  }
  
  Vec2 getPos() {
    return c.pos;
  }
}

// in your Init function:
movingCircle mc;
mc.init(0.1, p, Vec2(0.3, -0.5));
Vec2 pos = mc.getPos();
\end{code}

The \eeClass{Vec2} pos in the last line of code will contain the value 0.1. There are two things to remember about methods with a result:

\begin{itemize}
\item The type of the returned variable is used instead of void. In this case the method will return a position, so the return type has to be \eeClass{Vec2}.
\item Within the method, the instruction `return' is followed by the value that will be returned. This value will be passed to the the location where the method is called.
\end{itemize}

\begin{exercise}
Add the method above to your class. In your application, replace the code to check on the circle's position with your new method.
\end{exercise}

\section{Methods with Arguments and a Result}
It is possible to have Methods with both arguments and a result. But take care: although a method can have more than one argument, it never have more than one result.

You will be making a method called `move' in the next example. This method will move the circle by adding the argument to the current position. But it will only go ahead as long as the new position will fit within the screen boundaries. If the movement succeeds, the method will return true. If it fails, it will return false.

\begin{code}
class movingCircle {
  Circle c    ;
  Vec2   speed;
  
  void init(float r, Vec2 pos, Vec2 speed) {
    c.r         = r    ;
    c.pos       = pos  ;
    this->speed = speed;
  }
  
  float getRadius() {
    return c.r;
  }
  
  bool move(Vec2 pos) {
    if(Cuts(c.pos + pos, D.viewRect())) {
      c.pos += pos;
      return true;
    } else {
      return false;
    }
  }
}

// Somewhere in your Init function:
movingCircle mc;
Vec2 p(0, 0);
mc.init(0.1, p, Vec2(0.3, -0.5));
if( !mc.move(mc.speed * Time.d()) ) {
  // do something if failed
}
\end{code}

\begin{exercise}
Add the method \eeClass{move} to your class. In your application you can now use this method to move the circle instead of the more `manual' approach. Since the method also indicates if the circle was actually moved, you can remove the boundary check. When the method returns false, simply put the circle back in the middle.

The method `move' can be simplified even more. We know that in this application, we always want to move in the same direction. In other words, you could remove the method's argument and use the class variables to move to a new position.
\end{exercise}

\section{The Solution}
Below is the resulting code of everything we've done above. Compare this with your own result and make sure you understand what is happening in any lines that are different.

De class movingCircle:
\begin{code}
class movingCircle
{
   Circle c    ;
   Vec2   speed;
   Color  color;
   
   void create(float radius, Vec2 pos, Vec2 speed, Color color)
   {
      c.r     = radius;
      c.pos   = pos   ;
      T.speed = speed ;
      T.color = color ;
   }
   
   bool move()
   {
      Vec2 newPos = c.pos + speed * Time.d();
      if(Cuts(newPos, D.viewRect()))
      {
         c.pos = newPos;
         return true;
      } else return false;
   }
   
   Vec2 getPos()
   {
      return c.pos;
   }
   
   void setPos(Vec2 pos)
   {
      c.pos = pos;
   }
   
   void reset()
   {
      c.pos = 0;
   }
   
   void draw()
   {
      c.draw(color);
   }
}
\end{code}

The application:
\begin{code}
Memc<movingCircle> circles;

void InitPre()
{
   EE_INIT();
}

bool Init()
{ 
   return true;
}

void Shut() {}

bool Update()
{
   if(Kb.bp(KB_ESC)) return false;
  
   if(Kb.bp(KB_SPACE))
   {
      circles.New().create(RandomF(0.05, 0.1), 
                           Vec2(0), 
                           Vec2(RandomF(-1, 1), RandomF(-1, 1)), 
                           Color(Random(255), Random(255), Random(255))
                           );
   }
   
   if(Kb.bp(KB_F1))
   {
      REPA(circles)
      {
         circles[i].setPos(Vec2(RandomF(-D.w(), D.w()), RandomF(-D.h(), D.h())));
      }
   }
   
   REPA(circles)
   {
      if(!circles[i].move()) circles[i].reset();
   }
   
   return true;
}

void Draw()
{
   D.clear(BLACK);
  
   REPA(circles)
   {
      circles[i].draw();
   }
}
\end{code}
