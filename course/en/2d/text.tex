\chapter{Text}

There's no doubt you will need to show text on a screen eventually. Esenthel provides the class \eeClass{Str} to remember characters, words and even entire paragraphs.

There are several ways to put text into a \eeClass{Str}:

\begin{code}
Str text("hello world"); // use the constructor
text  = "hello "; // use assignment
tex += "world" ; // use the addition assignment operator
\end{code}

\textit{The text between quotes is officially called a `string literal'. When you don't have to do anything with a string but drawing it on screen, you can often just use a string literal.}

\section{Drawing Text}
Now let's try and draw some text on the screen. Contrary to the class \eeClass{Vec2}, the \eeClass{Str} class does not have a `draw' method. The object \eeClass{D} is used to show text on the screen:

\begin{code}
Str myString;
myString = "hello world";
D.text(Vec2(0, 0), myString); // place text in the middle of the screen
D.text(Vec2(0, -0.1), "Een string literal"); // or use a string literal
\end{code}

The second argument of the method \eeFunc{text} is the text itself. The first argument is the desired position. By now, you know enough about coordinates to understand why this has to be a \eeClass{Vec2}.

\begin{exercise}
Create an application that shows the words `left', `right', `top' and `bottom' on a logical screen position. Hide the mouse pointer and instead show the word `mouse' at the current mouse position.
\end{exercise}

\section{Combining text and numbers}
You cannot just combine text and numbers. As far as your computer knows, the values 42 and ``42'' have nothing to do with each other. The first one is an integer, the second one a string literal which happens to contain the characters 4 and 2. Examine this code:

\begin{code}
int i = 42;
Str myString;
mystring = i; // will generate an error
myString = 42; // an error
myString = "42"; // this is OK
D.text(Vec2(0, 0), i); // this is wrong: you cannot pass an integer to a method expecting a string
\end{code}

Still, you need to draw numbers on a screen eventually. To do that, add the number to a \eeClass{Str} object:

\begin{code}
int i = 42;
Str myString;
myString += i; // this is correct
myString += 42; // also correct
myString += 0.4; // also correct. myString now contains "42420.4"
D.text(Vec2(0, 0), myString); // draw the string on the screen.
\end{code}

It doesn't end here though. What if you'd like to combine text with numbers? See this:

\begin{code}
Str myString;
myString = "score: " + 42; // wrong!
myString = "score: ";
myString += 42; // correct!
\end{code}
 
What happened there? The first version doesn't work because the compiler tries to add 42 to the string literal ``score: '' first. Only after that it will try to assign the result to \eeClass{myString}. But adding something to a string literal won't work, because you can never change a literal.

The second version does work, because you assign the literal to the string first. Afterwards, the integer is added to the string.

Because you will want to combine integers (or floats) and strings quite a lot, there is a shortcut: a \eeClass{Str} object called \eeClass{S}. This object will always be an empty string.

\begin{code}
Str myString;
myString = S + "score: " + 42; // correct!
\end{code}

Why does this work? S is an empty \eeClass{Str}. Both the string literal and the integer will be added to S. Afterwards the text in S will be copied to myString.

An object like this can also be passed to \eeClass{D.text()}, so the following statements are completely fine:

\begin{code}
int myScore = 10;
D.text(Vec2(0, 0), S + "score: " + myScore);

// more complex
D.text(Vec2(0, 0), S + "score: " + myScore + " / 10");
\end{code}

\begin{exercise}
Create an application with an int `score'. Increase the score every time you press the space bar. Show the current score on the screen.
\end{exercise}

\section{Vec2 as text}
While debugging your application it can be useful to show the x- and y-coordinates of a \eeClass{Vec2} on the screen. You could do this the hard way:

\begin{code}
Vec2 pos = Ms.pos();
D.text(Vec2(0, 0), S + "x: " + pos.x + " y: " + pos.y);
\end{code}

However, you're certainly not the first programmer to draw a \eeClass{Vec2} on screen to check on its value. That's why the class as a method to make your life a little easier:

\begin{code}
Vec2 pos = Ms.pos();
D.text(Vec2(0, 0), S + pos.asText());
// or without the extra step:
D.text(Vec2(0, 0), Ms.pos().asText());
\end{code}

\begin{exercise}
Create an application with a dot which can be moved by means of the arrow keys. Show the position of the dot on the screen.
\end{exercise}

\section{Font and Size}
\label{chapter:tekstopmaak}
Drawing text is all well and good, but the default text probably isn't gonna do much for your game design. To customize this, you will need to provide your desired font. A new font can be added by right-clicking in the file-tree and choosing `New Font'. A dialog will open to change the font's settings.

Next you create a new textStyle. With a textStyle, you can define a color and alignment for a particular font. \textsl{(In the `font' drop down menu, the active font can be set.)} Even with one font, you can create as many textStyles as you like.

Now if you'd like to use your newly created textStyle to display text in your application, you can use an alternate version of \eeFunc{D.text()} :

\begin{code}
D.text(*TextStyles(=== drop style here ===), Vec2(0, 0), "text");
\end{code}

Just drag your textStyle over to the code editor and drop it as an argument of \eeFunc{TextStyles()}. Remember there's an asterisk right before this function. We'll discuss it later, but for now just remember it has to be there.

\begin{exercise}
Experiment with different options to shape a font and text style. Draw at least four different texts on the screen, each one with their own style.
\end{exercise}